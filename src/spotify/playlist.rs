use std::time::Duration;

use reqwest::{Client, StatusCode};
use tokio::time::sleep;

use crate::{
    config, error,
    management::TokenManager,
    types::{
        AddTrackToPlaylistRequest, AddTrackToPlaylistResponse, CreatePlaylistRequest,
        CreatePlaylistResponse, GetUserPlaylistsResponse, Track,
    },
};

pub async fn create(name: String) -> Result<CreatePlaylistResponse, reqwest::Error> {
    let mut token_mgr = match TokenManager::load().await {
        Ok(manager) => manager,
        Err(e) => {
            error!(
                "Failed to load token. Please run sporlcli auth\n Error: {}",
                e
            );
        }
    };

    let api_url = format!(
        "{url}/users/{user_id}/playlists",
        url = &config::spotify_apiurl(),
        user_id = &config::spotify_user()
    );

    loop {
        let client = Client::new();
        let token = token_mgr.get_valid_token().await;
        let response = client
            .post(&api_url)
            .bearer_auth(token)
            .json(&serde_json::json!(CreatePlaylistRequest {
                name: name.clone(),
                description: "[auto] Generated by SporlCLI".to_string(),
                public: false,
                collaborative: false
            }))
            .send()
            .await;

        let response = match response {
            Ok(resp) => match resp.error_for_status() {
                Ok(valid_response) => valid_response,
                Err(err) => {
                    if let Some(status) = err.status() {
                        if status == StatusCode::BAD_GATEWAY {
                            sleep(Duration::from_secs(10)).await;
                            continue; // retry
                        }
                    }

                    return Err(err); // propagate other errors
                }
            },
            Err(err) => {
                return Err(err);
            } // network or reqwest error
        };

        let json = response.json::<CreatePlaylistResponse>().await?;
        return Ok(json);
    }
}

pub async fn exists(playlist_name: &str) -> Result<bool, reqwest::Error> {
    let mut token_mgr = match TokenManager::load().await {
        Ok(manager) => manager,
        Err(e) => {
            error!(
                "Failed to load token. Please run sporlcli auth\n Error: {}",
                e
            );
        }
    };

    let api_url = format!("{url}/me/playlists", url = &config::spotify_apiurl());

    loop {
        let client = Client::new();
        let token = token_mgr.get_valid_token().await;
        let response = client.get(&api_url).bearer_auth(token).send().await;

        let response = match response {
            Ok(resp) => match resp.error_for_status() {
                Ok(valid_response) => valid_response,
                Err(err) => {
                    if let Some(status) = err.status() {
                        if status == StatusCode::BAD_GATEWAY {
                            sleep(Duration::from_secs(10)).await;
                            continue; // retry
                        }
                    }

                    return Err(err); // propagate other errors
                }
            },
            Err(err) => {
                return Err(err);
            } // network or reqwest error
        };

        let json = response.json::<GetUserPlaylistsResponse>().await?;
        for playlist in json.items {
            if playlist.name == playlist_name {
                return Ok(true);
            }
        }

        return Ok(false);
    }
}

pub async fn add_tracks(
    playlist_id: String,
    tracks: Vec<Track>,
) -> Result<AddTrackToPlaylistResponse, reqwest::Error> {
    let mut token_mgr = match TokenManager::load().await {
        Ok(manager) => manager,
        Err(e) => {
            error!(
                "Failed to load token. Please run sporlcli auth\n Error: {}",
                e
            );
        }
    };

    let api_url = format!(
        "{url}/playlists/{playlist_id}/tracks",
        url = &config::spotify_apiurl(),
        playlist_id = playlist_id,
    );

    loop {
        let client = Client::new();
        let token = token_mgr.get_valid_token().await;
        let response = client
            .post(&api_url)
            .bearer_auth(token)
            .json(&serde_json::json!(AddTrackToPlaylistRequest {
                uris: tracks.iter().map(|track| track.uri.clone()).collect()
            }))
            .send()
            .await;

        let response = match response {
            Ok(resp) => match resp.error_for_status() {
                Ok(valid_response) => valid_response,
                Err(err) => {
                    if let Some(status) = err.status() {
                        if status == StatusCode::BAD_GATEWAY {
                            sleep(Duration::from_secs(10)).await;
                            continue; // retry
                        }
                    }

                    return Err(err); // propagate other errors
                }
            },
            Err(err) => {
                return Err(err);
            } // network or reqwest error
        };

        let json = response.json::<AddTrackToPlaylistResponse>().await?;
        return Ok(json);
    }
}
