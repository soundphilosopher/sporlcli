use std::time::Duration;

use reqwest::{Client, StatusCode};
use tokio::time::sleep;

use crate::{
    config, error,
    management::TokenManager,
    types::{
        AddTrackToPlaylistRequest, AddTrackToPlaylistResponse, CreatePlaylistRequest,
        CreatePlaylistResponse, GetUserPlaylistsResponse, Track,
    },
};

/// Creates a new private playlist for the authenticated user.
///
/// Creates a playlist with the specified name and sets it as private with an
/// auto-generated description indicating it was created by SporlCLI. The playlist
/// is created under the authenticated user's account.
///
/// # Arguments
///
/// * `name` - The name for the new playlist
///
/// # Returns
///
/// Returns a `Result` containing:
/// - `Ok(CreatePlaylistResponse)` - Details of the created playlist including ID
/// - `Err(reqwest::Error)` - HTTP error, network error, or API error
///
/// # Authentication
///
/// Uses the stored token manager for authentication. If no valid token is found,
/// the function will terminate the program with an error message.
///
/// # Playlist Configuration
///
/// The created playlist has the following properties:
/// - **Name**: As specified in the parameter
/// - **Description**: "\\[auto\\] Generated by SporlCLI"
/// - **Public**: false (private playlist)
/// - **Collaborative**: false (only owner can edit)
///
/// # Retry Logic
///
/// Implements automatic retry for 502 Bad Gateway errors with a 10-second delay.
/// Other HTTP errors are propagated immediately to the caller.
///
/// # Error Handling
///
/// - Token loading failures result in program termination
/// - Network errors are propagated to the caller
/// - HTTP errors (except 502) are propagated immediately
///
/// # Example
///
/// ```
/// let playlist = create("New Releases - Week 42".to_string()).await?;
/// println!("Created playlist: {} (ID: {})", playlist.name, playlist.id);
/// ```
///
/// # API Limitations
///
/// - Playlist names must be unique within the user's account
/// - Maximum playlist name length is enforced by Spotify (typically 100 characters)
/// - Rate limits apply to playlist creation operations
pub async fn create(name: String) -> Result<CreatePlaylistResponse, reqwest::Error> {
    let mut token_mgr = match TokenManager::load().await {
        Ok(manager) => manager,
        Err(e) => {
            error!(
                "Failed to load token. Please run sporlcli auth\n Error: {}",
                e
            );
        }
    };

    let api_url = format!(
        "{url}/users/{user_id}/playlists",
        url = &config::spotify_apiurl(),
        user_id = &config::spotify_user()
    );

    loop {
        let client = Client::new();
        let token = token_mgr.get_valid_token().await;
        let response = client
            .post(&api_url)
            .bearer_auth(token)
            .json(&serde_json::json!(CreatePlaylistRequest {
                name: name.clone(),
                description: "[auto] Generated by SporlCLI".to_string(),
                public: false,
                collaborative: false
            }))
            .send()
            .await;

        let response = match response {
            Ok(resp) => match resp.error_for_status() {
                Ok(valid_response) => valid_response,
                Err(err) => {
                    if let Some(status) = err.status() {
                        if status == StatusCode::BAD_GATEWAY {
                            sleep(Duration::from_secs(10)).await;
                            continue; // retry
                        }
                    }

                    return Err(err); // propagate other errors
                }
            },
            Err(err) => {
                return Err(err);
            } // network or reqwest error
        };

        let json = response.json::<CreatePlaylistResponse>().await?;
        return Ok(json);
    }
}

/// Checks if a playlist with the given name already exists for the user.
///
/// Searches through the authenticated user's playlists to determine if a
/// playlist with the specified name already exists. This is useful for
/// avoiding duplicate playlist creation.
///
/// # Arguments
///
/// * `playlist_name` - The name of the playlist to search for
///
/// # Returns
///
/// Returns a `Result` containing:
/// - `Ok(true)` - A playlist with this name exists
/// - `Ok(false)` - No playlist with this name was found
/// - `Err(reqwest::Error)` - HTTP error, network error, or API error
///
/// # Authentication
///
/// Uses the stored token manager for authentication. If no valid token is found,
/// the function will terminate the program with an error message.
///
/// # Search Behavior
///
/// - Performs exact string matching on playlist names
/// - Case-sensitive comparison
/// - Searches only the current user's playlists
/// - Does not search playlists the user follows but doesn't own
///
/// # Performance Considerations
///
/// - Fetches all user playlists in a single request
/// - For users with many playlists, this may be slower than ideal
/// - Consider pagination for users with extensive playlist collections
///
/// # Retry Logic
///
/// Implements the same retry mechanism as other functions for 502 Bad Gateway
/// errors with a 10-second delay.
///
/// # Example
///
/// ```
/// let name = "New Releases - Week 42";
/// if exists(name).await? {
///     println!("Playlist '{}' already exists", name);
/// } else {
///     println!("Safe to create playlist '{}'", name);
/// }
/// ```
///
/// # Limitations
///
/// - Only checks the first page of playlists (typically up to 50)
/// - Does not handle pagination for users with >50 playlists
/// - Case-sensitive matching may miss variations in capitalization
pub async fn exists(playlist_name: &str) -> Result<bool, reqwest::Error> {
    let mut token_mgr = match TokenManager::load().await {
        Ok(manager) => manager,
        Err(e) => {
            error!(
                "Failed to load token. Please run sporlcli auth\n Error: {}",
                e
            );
        }
    };

    let api_url = format!("{url}/me/playlists", url = &config::spotify_apiurl());

    loop {
        let client = Client::new();
        let token = token_mgr.get_valid_token().await;
        let response = client.get(&api_url).bearer_auth(token).send().await;

        let response = match response {
            Ok(resp) => match resp.error_for_status() {
                Ok(valid_response) => valid_response,
                Err(err) => {
                    if let Some(status) = err.status() {
                        if status == StatusCode::BAD_GATEWAY {
                            sleep(Duration::from_secs(10)).await;
                            continue; // retry
                        }
                    }

                    return Err(err); // propagate other errors
                }
            },
            Err(err) => {
                return Err(err);
            } // network or reqwest error
        };

        let json = response.json::<GetUserPlaylistsResponse>().await?;
        for playlist in json.items {
            if playlist.name == playlist_name {
                return Ok(true);
            }
        }

        return Ok(false);
    }
}

/// Adds tracks to an existing playlist.
///
/// Appends the specified tracks to a playlist using their Spotify URIs.
/// All tracks are added in a single API request for efficiency. The tracks
/// are appended to the end of the playlist in the order provided.
///
/// # Arguments
///
/// * `playlist_id` - The Spotify ID of the playlist to add tracks to
/// * `tracks` - Vector of tracks to add, containing URIs and metadata
///
/// # Returns
///
/// Returns a `Result` containing:
/// - `Ok(AddTrackToPlaylistResponse)` - Response with snapshot ID of updated playlist
/// - `Err(reqwest::Error)` - HTTP error, network error, or API error
///
/// # Authentication
///
/// Uses the stored token manager for authentication. If no valid token is found,
/// the function will terminate the program with an error message.
///
/// # Track URIs
///
/// Extracts the URI field from each track object. Spotify URIs have the format:
/// `spotify:track:{track_id}` and are used to uniquely identify tracks for
/// playlist operations.
///
/// # Batch Operations
///
/// - All tracks are added in a single API request
/// - Maximum of 100 tracks per request (Spotify API limit)
/// - For larger sets, the caller should batch the requests
///
/// # Playlist Versioning
///
/// The response includes a snapshot ID that represents the current state of
/// the playlist after adding tracks. This can be used for conflict detection
/// and playlist versioning.
///
/// # Error Conditions
///
/// Common failures include:
/// - Invalid playlist ID
/// - User lacks permission to modify the playlist
/// - Invalid track URIs
/// - Tracks not available in user's market
/// - Network connectivity issues
///
/// # Retry Logic
///
/// Implements automatic retry for 502 Bad Gateway errors with a 10-second delay.
/// Other errors are propagated immediately.
///
/// # Example
///
/// ```
/// let tracks = vec![
///     Track { uri: "spotify:track:abc123".to_string(), ..Default::default() },
///     Track { uri: "spotify:track:def456".to_string(), ..Default::default() },
/// ];
///
/// let response = add_tracks("playlist_id".to_string(), tracks).await?;
/// println!("Playlist updated, snapshot: {}", response.snapshot_id);
/// ```
///
/// # API Limitations
///
/// - Maximum 100 tracks per request
/// - Playlist must be owned by the authenticated user or be collaborative
/// - Duplicate tracks are allowed (Spotify doesn't prevent duplicates)
/// - Some tracks may be unavailable in certain markets
pub async fn add_tracks(
    playlist_id: String,
    tracks: Vec<Track>,
) -> Result<AddTrackToPlaylistResponse, reqwest::Error> {
    let mut token_mgr = match TokenManager::load().await {
        Ok(manager) => manager,
        Err(e) => {
            error!(
                "Failed to load token. Please run sporlcli auth\n Error: {}",
                e
            );
        }
    };

    let api_url = format!(
        "{url}/playlists/{playlist_id}/tracks",
        url = &config::spotify_apiurl(),
        playlist_id = playlist_id,
    );

    loop {
        let client = Client::new();
        let token = token_mgr.get_valid_token().await;
        let response = client
            .post(&api_url)
            .bearer_auth(token)
            .json(&serde_json::json!(AddTrackToPlaylistRequest {
                uris: tracks.iter().map(|track| track.uri.clone()).collect()
            }))
            .send()
            .await;

        let response = match response {
            Ok(resp) => match resp.error_for_status() {
                Ok(valid_response) => valid_response,
                Err(err) => {
                    if let Some(status) = err.status() {
                        if status == StatusCode::BAD_GATEWAY {
                            sleep(Duration::from_secs(10)).await;
                            continue; // retry
                        }
                    }

                    return Err(err); // propagate other errors
                }
            },
            Err(err) => {
                return Err(err);
            } // network or reqwest error
        };

        let json = response.json::<AddTrackToPlaylistResponse>().await?;
        return Ok(json);
    }
}
